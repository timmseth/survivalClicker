name: Android CI

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'

      - name: Install unzip
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip

      - name: Unzip NeonSurvivor project
        run: |
          unzip NeonSurvivor2_project.zip -d .
          ls NeonSurvivor

      # AndroidX flags (harmless but future-proof)
      - name: Patch gradle.properties
        run: |
          cat > NeonSurvivor/gradle.properties << 'EOF'
          org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
          android.useAndroidX=true
          android.enableJetifier=true
          EOF

      - name: Patch app build.gradle
        run: |
          cat > NeonSurvivor/app/build.gradle << 'EOF'
          apply plugin: 'com.android.application'
          apply plugin: 'kotlin-android'

          android {
              namespace "com.example.neonsurvivor"
              compileSdk 34

              defaultConfig {
                  applicationId "com.example.neonsurvivor"
                  minSdk 24
                  targetSdk 34
                  versionCode 1
                  versionName "1.0"
              }

              buildTypes {
                  release {
                      minifyEnabled false
                      proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
                  }
              }

              compileOptions {
                  sourceCompatibility JavaVersion.VERSION_17
                  targetCompatibility JavaVersion.VERSION_17
              }
              kotlinOptions {
                  jvmTarget = "17"
              }
          }

          dependencies {
              implementation "org.jetbrains.kotlin:kotlin-stdlib:1.9.0"
          }
          EOF

      - name: Patch MainActivity
        run: |
          cat > NeonSurvivor/app/src/main/java/com/example/neonsurvivor/MainActivity.kt << 'EOF'
          package com.example.neonsurvivor

          import android.app.Activity
          import android.os.Bundle
          import android.view.View
          import android.view.WindowManager

          class MainActivity : Activity() {

              private lateinit var gameView: GameView

              override fun onCreate(savedInstanceState: Bundle?) {
                  super.onCreate(savedInstanceState)

                  window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
                  window.decorView.systemUiVisibility =
                      (View.SYSTEM_UI_FLAG_FULLSCREEN
                              or View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                              or View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY)

                  gameView = GameView(this)
                  setContentView(gameView)
              }

              override fun onPause() {
                  super.onPause()
                  gameView.pause()
              }

              override fun onResume() {
                  super.onResume()
                  gameView.resume()
              }
          }
          EOF

      # ðŸ”§ Fix GameView so it initializes once size is known
      - name: Patch GameView
        run: |
          cat > NeonSurvivor/app/src/main/java/com/example/neonsurvivor/GameView.kt << 'EOF'
          package com.example.neonsurvivor

          import android.content.Context
          import android.graphics.*
          import android.view.MotionEvent
          import android.view.View
          import kotlin.math.*
          import kotlin.random.Random

          class GameView(context: Context) : View(context) {

              private var lastTimeNs: Long = System.nanoTime()
              private var running: Boolean = true
              private var initialized: Boolean = false

              private val bgPaint = Paint().apply { color = Color.BLACK }
              private val gridPaint = Paint().apply {
                  color = Color.argb(40, 0, 255, 0)
                  strokeWidth = 1f
              }
              private val playerPaint = Paint().apply {
                  color = Color.CYAN
                  style = Paint.Style.FILL
                  isAntiAlias = true
              }
              private val enemyPaint = Paint().apply {
                  color = Color.MAGENTA
                  style = Paint.Style.STROKE
                  strokeWidth = 4f
                  isAntiAlias = true
              }
              private val bulletPaint = Paint().apply {
                  color = Color.GREEN
                  style = Paint.Style.STROKE
                  strokeWidth = 4f
                  isAntiAlias = true
              }
              private val bloodPaint = Paint().apply {
                  color = Color.RED
                  style = Paint.Style.FILL
                  isAntiAlias = true
              }
              private val textPaint = Paint().apply {
                  color = Color.WHITE
                  textSize = 40f
                  isAntiAlias = true
              }
              private val hpBgPaint = Paint().apply {
                  color = Color.DKGRAY
                  style = Paint.Style.FILL
              }
              private val hpFillPaint = Paint().apply {
                  color = Color.rgb(0, 200, 100)
                  style = Paint.Style.FILL
              }
              private val overlayPaint = Paint().apply {
                  color = Color.argb(190, 0, 0, 0)
                  style = Paint.Style.FILL
              }
              private val cardPaint = Paint().apply {
                  color = Color.argb(220, 30, 30, 30)
                  style = Paint.Style.FILL
                  isAntiAlias = true
              }
              private val cardBorderPaint = Paint().apply {
                  color = Color.CYAN
                  style = Paint.Style.STROKE
                  strokeWidth = 4f
                  isAntiAlias = true
              }

              private var playerX = 0f
              private var playerY = 0f
              private var playerRadius = 30f
              private var playerSpeed = 300f
              private var playerHp = 100
              private var maxHp = 100

              private var bulletDamage = 10f
              private var fireRate = 2f
              private var fireCooldown = 0f

              private var joyBaseX = 0f
              private var joyBaseY = 0f
              private var joyPointerId = -1
              private var joyActive = false
              private var joyDx = 0f
              private var joyDy = 0f
              private val joyBaseRadius = 110f
              private val joyKnobRadius = 50f
              private val joyBasePaint = Paint().apply {
                  color = Color.argb(80, 0, 255, 255)
                  style = Paint.Style.FILL
              }
              private val joyKnobPaint = Paint().apply {
                  color = Color.argb(160, 0, 255, 255)
                  style = Paint.Style.FILL
              }

              data class Enemy(var x: Float, var y: Float, var radius: Float, var speed: Float, var hp: Float)
              data class Bullet(var x: Float, var y: Float, var vx: Float, var vy: Float)
              data class BloodParticle(var x: Float, var y: Float, var vx: Float, var vy: Float, var life: Float)

              private val enemies = mutableListOf<Enemy>()
              private val bullets = mutableListOf<Bullet>()
              private val blood = mutableListOf<BloodParticle>()

              private var wave = 1
              private var inGacha = false

              enum class UpgradeType { DAMAGE, FIRE_RATE, SPEED, HP }
              data class UpgradeOption(val type: UpgradeType, val label: String, val desc: String)
              private val upgradeOptions = mutableListOf<UpgradeOption>()

              init {
                  isFocusable = true
                  isClickable = true
              }

              fun pause() {
                  running = false
              }

              fun resume() {
                  running = true
                  if (initialized) {
                      lastTimeNs = System.nanoTime()
                      postInvalidateOnAnimation()
                  }
              }

              override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {
                  super.onSizeChanged(w, h, oldw, oldh)
                  if (!initialized && w > 0 && h > 0) {
                      playerX = w / 2f
                      playerY = h / 2f
                      joyBaseX = w * 0.18f
                      joyBaseY = h * 0.8f
                      spawnWave()
                      lastTimeNs = System.nanoTime()
                      running = true
                      initialized = true
                      postInvalidateOnAnimation()
                  }
              }

              override fun onDraw(canvas: Canvas) {
                  super.onDraw(canvas)

                  if (!initialized) {
                      // no size yet; just draw black
                      canvas.drawRect(0f, 0f, width.toFloat(), height.toFloat(), bgPaint)
                      return
                  }

                  val now = System.nanoTime()
                  var dt = (now - lastTimeNs) / 1_000_000_000f
                  if (dt > 0.05f) dt = 0.05f
                  lastTimeNs = now

                  if (running) {
                      update(dt)
                  }

                  drawInternal(canvas)

                  if (running) {
                      postInvalidateOnAnimation()
                  }
              }

              private fun spawnWave() {
                  enemies.clear()
                  val count = 5 + wave * 2
                  val rnd = Random(System.currentTimeMillis())
                  val w = width.toFloat()
                  val h = height.toFloat()
                  for (i in 0 until count) {
                      val edge = rnd.nextInt(4)
                      val ex: Float
                      val ey: Float
                      when (edge) {
                          0 -> { ex = rnd.nextFloat() * w; ey = -60f }
                          1 -> { ex = rnd.nextFloat() * w; ey = h + 60f }
                          2 -> { ex = -60f; ey = rnd.nextFloat() * h }
                          else -> { ex = w + 60f; ey = rnd.nextFloat() * h }
                      }
                      val baseSpeed = 60f + wave * 10f
                      val hp = 30f + wave * 5f
                      enemies.add(Enemy(ex, ey, 24f, baseSpeed, hp))
                  }
                  if (playerHp <= 0) {
                      playerHp = maxHp
                  }
                  inGacha = false
              }

              private fun update(dt: Float) {
                  if (playerHp <= 0) {
                      wave = 1
                      playerHp = maxHp
                      bulletDamage = 10f
                      fireRate = 2f
                      playerSpeed = 300f
                      spawnWave()
                      return
                  }

                  if (!inGacha) {
                      updatePlayer(dt)
                      updateEnemies(dt)
                      updateBullets(dt)
                      handleAutoFire(dt)
                  }

                  updateBlood(dt)

                  if (!inGacha && enemies.isEmpty()) {
                      openGacha()
                  }
              }

              private fun updatePlayer(dt: Float) {
                  if (joyActive) {
                      val len = hypot(joyDx.toDouble(), joyDy.toDouble()).toFloat()
                      if (len > 0.01f) {
                          val nx = joyDx / len
                          val ny = joyDy / len
                          playerX += nx * playerSpeed * dt
                          playerY += ny * playerSpeed * dt
                      }
                  }
                  val w = width.toFloat()
                  val h = height.toFloat()
                  playerX = playerX.coerceIn(playerRadius, w - playerRadius)
                  playerY = playerY.coerceIn(playerRadius, h - playerRadius)
              }

              private fun updateEnemies(dt: Float) {
                  val it = enemies.iterator()
                  while (it.hasNext()) {
                      val e = it.next()
                      val dx = playerX - e.x
                      val dy = playerY - e.y
                      val dist = hypot(dx.toDouble(), dy.toDouble()).toFloat()
                      if (dist > 1f) {
                          val nx = dx / dist
                          val ny = dy / dist
                          e.x += nx * e.speed * dt
                          e.y += ny * e.speed * dt
                      }
                      if (dist < e.radius + playerRadius) {
                          playerHp -= (15f * dt).toInt()
                          if (playerHp < 0) playerHp = 0
                      }
                  }
              }

              private fun updateBullets(dt: Float) {
                  val bulletIt = bullets.iterator()
                  val w = width.toFloat()
                  val h = height.toFloat()
                  while (bulletIt.hasNext()) {
                      val b = bulletIt.next()
                      b.x += b.vx * dt
                      b.y += b.vy * dt

                      if (b.x < -100 || b.x > w + 100 || b.y < -100 || b.y > h + 100) {
                          bulletIt.remove()
                          continue
                      }

                      var hitEnemy: Enemy? = null
                      for (e in enemies) {
                          val dx = e.x - b.x
                          val dy = e.y - b.y
                          val dist = hypot(dx.toDouble(), dy.toDouble()).toFloat()
                          if (dist < e.radius) {
                              hitEnemy = e
                              break
                          }
                      }
                      if (hitEnemy != null) {
                          hitEnemy.hp -= bulletDamage
                          spawnBlood(hitEnemy.x, hitEnemy.y)
                          bulletIt.remove()
                          if (hitEnemy.hp <= 0f) {
                              enemies.remove(hitEnemy)
                          }
                      }
                  }
              }

              private fun handleAutoFire(dt: Float) {
                  if (enemies.isEmpty()) return
                  fireCooldown -= dt
                  if (fireCooldown > 0f) return

                  var target: Enemy? = null
                  var bestDist2 = Float.MAX_VALUE
                  for (e in enemies) {
                      val dx = e.x - playerX
                      val dy = e.y - playerY
                      val d2 = dx * dx + dy * dy
                      if (d2 < bestDist2) {
                          bestDist2 = d2
                          target = e
                      }
                  }

                  target?.let {
                      val dx = it.x - playerX
                      val dy = it.y - playerY
                      val dist = hypot(dx.toDouble(), dy.toDouble()).toFloat()
                      if (dist > 1f) {
                          val nx = dx / dist
                          val ny = dy / dist
                          val bulletSpeed = 700f
                          bullets.add(Bullet(playerX, playerY, nx * bulletSpeed, ny * bulletSpeed))
                          fireCooldown = 1f / fireRate
                      }
                  }
              }

              private fun spawnBlood(x: Float, y: Float) {
                  val rnd = Random(System.nanoTime())
                  for (i in 0 until 12) {
                      val angle = rnd.nextFloat() * (2f * Math.PI.toFloat())
                      val speed = 80f + rnd.nextFloat() * 120f
                      val vx = cos(angle) * speed
                      val vy = sin(angle) * speed
                      blood.add(BloodParticle(x, y, vx, vy, 0.6f + rnd.nextFloat() * 0.4f))
                  }
              }

              private fun updateBlood(dt: Float) {
                  val it = blood.iterator()
                  while (it.hasNext()) {
                      val p = it.next()
                      p.x += p.vx * dt
                      p.y += p.vy * dt
                      p.life -= dt
                      if (p.life <= 0f) it.remove()
                  }
              }

              private fun openGacha() {
                  inGacha = true
                  upgradeOptions.clear()
                  val allTypes = UpgradeType.values().toMutableList()
                  allTypes.shuffle()
                  val chosen = allTypes.take(3)
                  for (t in chosen) {
                      when (t) {
                          UpgradeType.DAMAGE ->
                              upgradeOptions.add(
                                  UpgradeOption(t, "Damage +30%", "Bullets hit harder.")
                              )
                          UpgradeType.FIRE_RATE ->
                              upgradeOptions.add(
                                  UpgradeOption(t, "Fire Rate +30%", "Shoot more often.")
                              )
                          UpgradeType.SPEED ->
                              upgradeOptions.add(
                                  UpgradeOption(t, "Speed +20%", "Move faster.")
                              )
                          UpgradeType.HP ->
                              upgradeOptions.add(
                                  UpgradeOption(t, "HP Boost", "Max HP +20 and heal.")
                              )
                      }
                  }
              }

              private fun applyUpgrade(option: UpgradeOption) {
                  when (option.type) {
                      UpgradeType.DAMAGE -> bulletDamage *= 1.3f
                      UpgradeType.FIRE_RATE -> fireRate *= 1.3f
                      UpgradeType.SPEED -> playerSpeed *= 1.2f
                      UpgradeType.HP -> {
                          maxHp += 20
                          playerHp = maxHp
                      }
                  }
                  wave += 1
                  spawnWave()
                  inGacha = false
              }

              private fun handleGachaTouch(x: Float, y: Float) {
                  if (!inGacha) return
                  val w = width.toFloat()
                  val h = height.toFloat()
                  val cardWidth = w * 0.8f
                  val cardHeight = h * 0.12f
                  val startX = (w - cardWidth) / 2f
                  val firstY = h * 0.35f
                  val gap = cardHeight + h * 0.03f

                  for (i in upgradeOptions.indices) {
                      val top = firstY + i * gap
                      val rect = RectF(
                          startX,
                          top,
                          startX + cardWidth,
                          top + cardHeight
                      )
                      if (rect.contains(x, y)) {
                          applyUpgrade(upgradeOptions[i])
                          return
                      }
                  }
              }

              override fun onTouchEvent(event: MotionEvent): Boolean {
                  val action = event.actionMasked
                  val index = event.actionIndex

                  if (inGacha && (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP)) {
                      val x = event.getX(index)
                      val y = event.getY(index)
                      handleGachaTouch(x, y)
                      return true
                  }

                  when (action) {
                      MotionEvent.ACTION_DOWN,
                      MotionEvent.ACTION_POINTER_DOWN -> {
                          val x = event.getX(index)
                          val y = event.getY(index)
                          if (x < width * 0.5f && y > height * 0.5f && joyPointerId == -1) {
                              joyPointerId = event.getPointerId(index)
                              joyBaseX = x
                              joyBaseY = y
                              joyDx = 0f
                              joyDy = 0f
                              joyActive = true
                          }
                      }

                      MotionEvent.ACTION_MOVE -> {
                          if (joyPointerId != -1) {
                              val pIndex = event.findPointerIndex(joyPointerId)
                              if (pIndex != -1) {
                                  val x = event.getX(pIndex)
                                  val y = event.getY(pIndex)
                                  joyDx = x - joyBaseX
                                  joyDy = y - joyBaseY
                                  val len = hypot(joyDx.toDouble(), joyDy.toDouble()).toFloat()
                                  if (len > joyBaseRadius) {
                                      val scale = joyBaseRadius / len
                                      joyDx *= scale
                                      joyDy *= scale
                                  }
                              }
                          }
                      }

                      MotionEvent.ACTION_UP,
                      MotionEvent.ACTION_POINTER_UP,
                      MotionEvent.ACTION_CANCEL -> {
                          val pid = event.getPointerId(index)
                          if (pid == joyPointerId) {
                              joyPointerId = -1
                              joyActive = false
                              joyDx = 0f
                              joyDy = 0f
                          }
                      }
                  }
                  return true
              }

              private fun drawInternal(canvas: Canvas) {
                  val w = width.toFloat()
                  val h = height.toFloat()
                  canvas.drawRect(0f, 0f, w, h, bgPaint)

                  var x = 0f
                  while (x < w) {
                      canvas.drawLine(x, 0f, x, h, gridPaint)
                      x += 80f
                  }

                  for (p in blood) {
                      val alpha = (255f * p.life.coerceIn(0f, 1f)).toInt()
                      bloodPaint.alpha = alpha
                      canvas.drawCircle(p.x, p.y, 6f, bloodPaint)
                  }

                  for (b in bullets) {
                      canvas.drawCircle(b.x, b.y, 6f, bulletPaint)
                  }

                  for (e in enemies) {
                      canvas.drawCircle(e.x, e.y, e.radius, enemyPaint)
                  }

                  canvas.drawCircle(playerX, playerY, playerRadius, playerPaint)

                  val barWidth = w * 0.6f
                  val barHeight = 24f
                  val barX = (w - barWidth) / 2f
                  val barY = 40f
                  canvas.drawRect(barX, barY, barX + barWidth, barY + barHeight, hpBgPaint)
                  val hpRatio = (playerHp.toFloat() / maxHp.toFloat()).coerceIn(0f, 1f)
                  canvas.drawRect(barX, barY, barX + barWidth * hpRatio, barY + barHeight, hpFillPaint)
                  canvas.drawText("Wave $wave", 20f, barY + barHeight + 40f, textPaint)

                  if (joyActive) {
                      canvas.drawCircle(joyBaseX, joyBaseY, joyBaseRadius, joyBasePaint)
                      val knobX = joyBaseX + joyDx
                      val knobY = joyBaseY + joyDy
                      canvas.drawCircle(knobX, knobY, joyKnobRadius, joyKnobPaint)
                  } else {
                      canvas.drawCircle(joyBaseX, joyBaseY, joyBaseRadius * 0.5f, joyBasePaint)
                  }

                  if (inGacha) {
                      canvas.drawRect(0f, 0f, w, h, overlayPaint)
                      canvas.drawText("Choose an upgrade:", w * 0.1f, h * 0.25f, textPaint)

                      val cardWidth = w * 0.8f
                      val cardHeight = h * 0.12f
                      val startX = (w - cardWidth) / 2f
                      val firstY = h * 0.35f
                      val gap = cardHeight + h * 0.03f

                      upgradeOptions.forEachIndexed { i, opt ->
                          val top = firstY + i * gap
                          val rect = RectF(
                              startX,
                              top,
                              startX + cardWidth,
                              top + cardHeight
                          )
                          canvas.drawRoundRect(rect, 16f, 16f, cardPaint)
                          canvas.drawRoundRect(rect, 16f, 16f, cardBorderPaint)
                          canvas.drawText(opt.label, rect.left + 40f, rect.top + 60f, textPaint)
                          canvas.drawText(opt.desc, rect.left + 40f, rect.top + 110f, textPaint)
                      }
                  }
              }
          }
          EOF

      - name: Build with Gradle
        uses: gradle/gradle-build-action@v3
        with:
          gradle-version: 8.7
          arguments: assembleDebug
          build-root-directory: NeonSurvivor

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: neon-survivor-apk
          path: NeonSurvivor/app/build/outputs/apk/debug/app-debug.apk